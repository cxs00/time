# Cursor AI 助手配置 - Activity Tracker 项目

---

## 📑 规则索引（快速定位） - RULES INDEX

**使用方法：** 使用 `grep -n "关键词" .cursorrules` 快速定位到对应行

### 🔴 核心规则（最高优先级）
- **元规则（Meta Rules）** - 行70-99：规则优先级原则
- **实时错误回退系统** - 行1237-1503：自动快照和回退
- **强制执行检查点系统** - 行1505-1581：4个强制检查点
- **自动化沙盒验证流程** - 行1604-1784：修改前必须沙盒验证
- **专业代码设计规范** - 行1329-1600：代码设计标准

### 📋 开发规范
- **数据存储规范** - 行268-295：数据结构定义
- **项目状态规范** - 行72-111：状态值定义
- **JavaScript语法规范** - 行112-141：代码风格
- **全局变量引用规范** - 行142-160：window前缀
- **数据验证规范** - 行161-180：验证函数

### 🔧 开发流程
- **自动仿真规则** - 行45-70：修改后自动运行仿真
- **修改前检查清单** - 行182-201：必须检查项
- **修改后验证清单** - 行203-222：验证项目
- **完整验证流程** - 行520-631：验证闭环

### 🐛 问题记录
- **已解决的历史问题** - 行224-389：问题案例库
- **解决方案知识库系统** - 行634-750：自动记录机制

### 🌍 跨平台
- **跨平台一致性验证** - 行754-821：平台验证矩阵
- **平台特定适配** - 行788-821：iOS/macOS/Web适配

### 💾 备份与版本
- **文档同步与备份机制** - 行877-933：备份策略
- **Git版本标记** - 行918-942：Tag命名规则
- **Git双向同步规则** - 行944-1233：本地↔云端同步

### 🎯 快速搜索命令
```bash
# 搜索数据存储相关规则
grep -i "数据存储\|localStorage\|STORAGE_KEYS" .cursorrules

# 搜索状态相关规则
grep -i "状态\|status\|PROJECT_STATUS" .cursorrules

# 搜索验证相关规则
grep -i "验证\|检查点\|沙盒" .cursorrules

# 搜索Git相关规则
grep -i "git\|版本号\|tag" .cursorrules

# 搜索跨平台相关规则
grep -i "跨平台\|iOS\|macOS\|安全区域" .cursorrules

# 搜索代码规范
grep -i "JavaScript\|CSS\|HTML\|BEM" .cursorrules
```

### 📊 规则统计
- 总行数：1422行
- 规则版本：Activity-Tracker-Rules-v5.0.0
- 主要章节：8个
- 检查点：4个
- 代码示例：50+个

---

## ⚠️ 最高优先级：元规则（Meta Rules）- CRITICAL

### 🔴 规则优先级原则（所有行为的最高准则）

```
┌──────────────────────────────────────────────────────────────┐
│                                                              │
│  任何行为，如果已有制定好的规则，必须优先参照规则执行        │
│                                                              │
│  规则 > 惯例 > 常识 > AI判断                                 │
│                                                              │
└──────────────────────────────────────────────────────────────┘
```

**核心要求：**

1. **执行任何操作前，必须先搜索并检查是否已有相关规则**
2. **规则存在时，严格按规则执行，AI 无自由裁量权**
3. **规则不存在时，使用行业最佳实践并告知用户**
4. **规则冲突时，停止执行并请求用户澄清**

**规则层级（优先级从高到低）：**

1️⃣ 本项目 .cursorrules 文件中的规则（最高优先级）
2️⃣ 行业标准和最佳实践（无本项目规则时）
3️⃣ AI 的经验和判断（最低优先级，仅作建议）

**记住：规则是法律，不是建议。质疑规则？可以。违反规则？不可以。**

---

## 项目类型
这是一个智能活动记录与进度管理系统，包含Web版本和原生iOS/macOS应用。

## 技术栈
- 前端：HTML5, CSS3, JavaScript ES6+
- 原生：SwiftUI (iOS/macOS)
- 数据：LocalStorage, ECharts
- 工具：Git, Xcode, Cursor

## 🚀 自动化工作流程

### 自动仿真规则 - MUST FOLLOW
**每次Cursor完成代码修改后，必须自动运行仿真验证**

```bash
# 标准流程：
1. 完成代码修改
2. 等待10秒（确保文件保存完成）
3. 自动运行Mac和iPhone仿真
4. 显示验证清单

# 执行命令：
sleep 10 && cd /Users/shanwanjun/Desktop/cxs/time/time && echo "3" | ./run-simulation.sh
```

**例外情况（不运行仿真）：**
- 仅修改文档文件（*.md）
- 仅修改配置文件（.cursorrules, .gitignore等）
- 用户明确说明"不要运行仿真"
- 仅进行Git操作（commit, tag等）

**仿真验证要点：**
- 检查编译是否成功
- 检查应用是否正常启动
- 检查控制台是否有错误
- 提醒用户验证修改的功能

## 🚨 关键开发规范（避免错误）

### 1. 数据存储规范 - MUST FOLLOW
```javascript
// ✅ 正确：统一使用前缀键名
const STORAGE_KEYS = {
  ACTIVITIES: 'activityTracker_activities',
  PROJECTS: 'activityTracker_projects',
  DIARY: 'activityTracker_diary',
  MEMOS: 'activityTracker_memos'
};
localStorage.setItem(STORAGE_KEYS.PROJECTS, JSON.stringify(projects));
const projects = JSON.parse(localStorage.getItem(STORAGE_KEYS.PROJECTS) || '[]');

// ❌ 错误：使用简单键名
localStorage.setItem('projects', ...); // 禁止
localStorage.getItem('projects'); // 禁止
```

### 2. 项目状态规范 - MUST FOLLOW
```javascript
// ✅ 正确：统一使用英文状态
const PROJECT_STATUS = {
  ACTIVE: 'active',
  COMPLETED: 'completed',
  PAUSED: 'paused'
};
{ id: 1, name: '项目1', status: 'active' }

// ❌ 错误：使用中文状态
{ id: 1, name: '项目1', status: '进行中' } // 禁止
```

### 3. JavaScript语法规范 - MUST FOLLOW
```javascript
// ✅ 正确：使用反引号或英文引号
console.log(`✅ 数据加载完成`);
const message = "Hello World";

// ❌ 错误：使用中文引号
console.log(`✅ 数据加载完成"); // 禁止
```

### 4. 全局变量引用规范 - MUST FOLLOW
```javascript
// ✅ 正确：使用window.前缀
if (typeof window.chartManager === 'undefined') {
  console.error('图表管理器未加载');
  return;
}
window.chartManager.updateActivityPieChart(activities);

// ❌ 错误：直接引用
if (typeof chartManager === 'undefined') // 禁止
chartManager.updateActivityPieChart(activities); // 禁止
```

### 5. 数据验证规范 - MUST FOLLOW
```javascript
// ✅ 必须添加数据验证
function validateProjectData(project) {
  if (!project || typeof project !== 'object') {
    throw new Error('Project data must be an object');
  }
  if (!project.id || !project.name) {
    throw new Error('Project must have id and name');
  }
  if (!['active', 'completed', 'paused'].includes(project.status)) {
    throw new Error('Invalid project status');
  }
  return true;
}
```

## 🔧 开发流程规范

### 修改前检查清单
- [ ] 数据键名是否使用统一前缀
- [ ] 项目状态是否使用英文值
- [ ] JavaScript语法是否正确（无中文引号）
- [ ] 全局变量是否使用window.前缀
- [ ] 是否添加了数据验证

### 修改后验证清单
- [ ] 项目选择器是否显示正确数量的项目
- [ ] 界面切换是否正常工作
- [ ] 图表是否正常显示
- [ ] 控制台是否有错误信息
- [ ] 数据是否正确保存和读取

## 开发规范
- 使用现代JavaScript语法
- 遵循响应式设计原则
- 保持代码整洁和注释
- 支持多设备适配

## 功能要求
- 智能活动记录（AI分类）
- 项目进度管理
- 数据统计和分析
- 日记和备忘录
- 响应式UI设计
- 跨平台兼容性

## 代码风格
- 使用有意义的变量名
- 添加必要的注释
- 遵循ES6+语法
- 保持代码简洁

## 项目结构
```
TIME/
├── activity-tracker.html          # 主应用入口
├── demo-activity-tracker.html     # 功能演示页面
├── css/activity-tracker.css       # 样式文件
├── js/                            # JavaScript功能
│   ├── activity-tracker.js        # 活动记录核心
│   ├── project-manager.js         # 项目管理
│   ├── diary-memo.js              # 日记备忘
│   ├── ai-classifier.js           # AI分类器
│   └── app-main.js                # 主应用逻辑
├── time/                          # iOS/macOS项目
└── scripts/                        # 工具脚本
```

## 认证信息自动导入
当检测到 ~/.cxs-auth/ 目录时，自动执行以下操作：

1. **检测认证目录**
   ```bash
   if [ -d ~/.cxs-auth ]; then
     echo "检测到认证目录，开始导入..."
     ./scripts/auto-import-auth.sh
   fi
   ```

2. **导入GitHub认证**
   - 自动设置Git用户名和邮箱
   - 配置GitHub Token
   - 设置远程仓库

3. **导入Netlify认证**
   - 设置环境变量
   - 配置部署信息
   - 启用自动部署

4. **导入其他认证**
   - Vercel认证（可选）
   - Cursor配置
   - 项目特定设置

## 开发原则
- 代码简洁可读
- 功能完整可用
- 性能优化
- 用户体验优先
- 跨平台兼容

## 响应格式
- 提供清晰的代码示例
- 解释实现原理
- 给出优化建议
- 提供测试方法

## 认证信息处理
- 检测到认证目录时自动导入
- 不询问用户确认（静默导入）
- 显示导入状态和结果
- 验证认证信息有效性

## 隐私保护
- 认证信息存储在 ~/.cxs-auth/ 目录
- 该目录不上传Git仓库
- 本地加密存储（可选）
- 自动清理过期Token

## 项目状态
- 当前版本：Activity-Tracker-v2.6.0
- 开发状态：核心功能完成，持续优化中
- 下一步：修复当前问题，完善功能
- 文档：查看 PROJECT_STATUS.md

## 快速开始
1. 检测认证目录：~/.cxs-auth/
2. 自动导入认证信息
3. 启动开发环境
4. 开始开发或部署

## 注意事项
- 认证信息不上传Git
- 本地开发环境配置
- 跨平台兼容性
- 性能优化考虑

## 📊 数据一致性规范

### 标准项目数据结构
```javascript
const standardProject = {
  id: 'string',           // 唯一标识符
  name: 'string',         // 项目名称
  description: 'string',  // 项目描述
  status: 'active',       // 状态：active/completed/paused
  progress: 0,            // 进度：0-100
  priority: 'medium',     // 优先级：high/medium/low
  startDate: 'ISOString', // 开始日期
  targetDate: 'ISOString' // 目标日期
};
```

### 标准活动数据结构
```javascript
const standardActivity = {
  id: 'string',           // 唯一标识符
  text: 'string',         // 活动描述
  category: 'string',     // 活动分类
  startTime: 'ISOString', // 开始时间
  endTime: 'ISOString',   // 结束时间
  duration: 0,            // 持续时间（分钟）
  project: 'string'       // 关联项目ID
};
```

## 🚨 常见错误预防

### 错误1：数据键名不一致
```javascript
// ❌ 错误
localStorage.setItem('projects', data);
const projects = localStorage.getItem('activityTracker_projects');

// ✅ 正确
localStorage.setItem('activityTracker_projects', data);
const projects = localStorage.getItem('activityTracker_projects');
```

### 错误2：项目状态不统一
```javascript
// ❌ 错误
{ status: '进行中' }
projects.filter(p => p.status === 'active');

// ✅ 正确
{ status: 'active' }
projects.filter(p => p.status === 'active');
```

### 错误3：中文引号语法错误
```javascript
// ❌ 错误
console.log(`数据加载完成");

// ✅ 正确
console.log(`数据加载完成`);
```

### 错误4：全局变量引用错误
```javascript
// ❌ 错误
if (typeof chartManager === 'undefined')

// ✅ 正确
if (typeof window.chartManager === 'undefined')
```

## 🧪 测试规范

### 功能测试清单
- [ ] 项目选择器显示正确的项目数量
- [ ] 项目状态过滤功能正常
- [ ] 活动记录功能正常
- [ ] 数据保存和读取正常
- [ ] 界面切换流畅
- [ ] 图表显示正常
- [ ] 移动端适配正常

### 错误处理规范
```javascript
// ✅ 必须添加错误处理
try {
  const data = JSON.parse(localStorage.getItem('activityTracker_projects') || '[]');
  return data;
} catch (error) {
  console.error('加载项目数据失败:', error);
  return [];
}

// ✅ 必须添加空值检查
const element = document.getElementById('projectSelect');
if (!element) {
  console.error('元素未找到');
  return;
}
```

## 🚀 快速修复指南

### 遇到项目选择器问题时
1. 检查localStorage键名是否一致
2. 检查项目状态是否为'active'
3. 检查数据加载时机是否正确
4. 检查DOM元素是否存在

### 遇到界面切换问题时
1. 检查JavaScript语法错误
2. 检查全局变量引用
3. 检查事件监听器是否正确绑定
4. 检查CSS样式是否正确加载

### 遇到图表显示问题时
1. 检查ECharts是否正确加载
2. 检查图表容器是否存在
3. 检查数据格式是否正确
4. 检查图表初始化时机

---

## 🐛 已解决的历史问题记录

### 问题1：暂停按钮无响应（已解决 ✅）
**问题描述：** 记录界面中的暂停按钮点击后无任何反应
**根本原因：**
- 暂停按钮缺少事件监听器绑定
- 缺少 `pauseActivity()` 和 `resumeActivity()` 方法实现
- UI未根据暂停状态动态更新

**解决方案：**
```javascript
// 1. 在setupEventListeners()中添加事件监听器
const pauseBtn = document.getElementById('pauseActivity');
if (pauseBtn) {
  pauseBtn.addEventListener('click', () => this.handlePauseActivity());
}

// 2. 实现暂停/继续逻辑
handlePauseActivity() {
  if (this.currentActivity.isPaused) {
    this.resumeActivity();
  } else {
    this.pauseActivity();
  }
}

// 3. 暂停时调整时间，排除暂停时长
pauseActivity() {
  this.currentActivity.isPaused = true;
  this.currentActivity.pauseTime = new Date();
  this.stopTimer();
}

resumeActivity() {
  const pauseDuration = new Date() - this.currentActivity.pauseTime;
  this.currentActivity.startTime = new Date(this.currentActivity.startTime.getTime() + pauseDuration);
  this.currentActivity.isPaused = false;
  this.startTimer();
}

// 4. UI动态更新
if (this.currentActivity.isPaused) {
  pauseBtn.textContent = '▶️ 继续';
  pauseBtn.classList.add('btn-resume');
} else {
  pauseBtn.textContent = '⏸️ 暂停';
  pauseBtn.classList.add('btn-pause');
}
```

**预防措施：**
- 所有按钮必须在 `setupEventListeners()` 中绑定事件
- 按钮功能必须有对应的处理方法
- UI状态必须与数据状态同步更新

### 问题2：选项卡超出系统状态栏（已解决 ✅）
**问题描述：** iPhone上滑动时，内容卡片会显示在系统状态栏上方
**根本原因：**
- 缺少 `viewport-fit=cover` 启用iOS安全区域
- 未使用 `env(safe-area-inset-*)` 处理刘海屏/灵动岛
- 导航栏 `z-index` 不够高，被滚动内容覆盖

**解决方案：**
```html
<!-- 1. HTML meta标签 -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
```

```css
/* 2. 内联CSS - 基础安全区域 */
body {
  padding-top: env(safe-area-inset-top);
  padding-bottom: env(safe-area-inset-bottom);
}

.navbar {
  padding-top: max(1rem, env(safe-area-inset-top));
  z-index: 1000; /* 确保最高层级 */
}

/* 3. 外部CSS - 完整支持 */
@supports (padding: env(safe-area-inset-top)) {
  .navbar {
    padding-top: max(1rem, env(safe-area-inset-top));
    padding-left: max(2rem, env(safe-area-inset-left));
    padding-right: max(2rem, env(safe-area-inset-right));
    z-index: 1000;
  }

  .page, .container, .project-card {
    position: relative;
    z-index: 1;
  }
}

/* 4. 移动端优化 */
@media (max-width: 768px) {
  @supports (padding: env(safe-area-inset-top)) {
    .navbar {
      padding-top: max(0.75rem, env(safe-area-inset-top));
    }
  }
}
```

**预防措施：**
- 所有iOS/macOS应用必须添加 `viewport-fit=cover`
- 导航栏必须使用 `z-index: 1000` 或更高
- 使用 `@supports` 进行渐进增强
- 移动端必须单独优化安全区域

---

**重要提醒：**
- 每次修改前必须阅读本规范
- 遇到问题时首先检查本规范和历史问题记录
- 定期更新和优化本规范
- 所有开发人员必须遵循本规范
- 新问题解决后必须记录到此处

---

## 🔄 完整验证流程规范 v3.0 - MUST FOLLOW

### 验证闭环流程（强制执行，不可跳过）

**每次提出新的代码解决方案后，必须执行完整的验证流程**

```
┌─────────────────────────────────────────────────────────────┐
│ 验证闭环流程（循环直到成功）                                 │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│ 1️⃣ 设计解决方案                                            │
│    ↓                                                        │
│ 2️⃣ 编译验证                                                │
│    ├─ ✅ 通过 → 继续                                       │
│    └─ ❌ 失败 → 🔄 重新设计 → 回到步骤1                   │
│    ↓                                                        │
│ 3️⃣ 仿真测试                                                │
│    ├─ ✅ 通过 → 继续                                       │
│    └─ ❌ 失败 → 🔄 重新设计 → 回到步骤1                   │
│    ↓                                                        │
│ 4️⃣ 全局影响分析                                            │
│    ├─ ✅ 无影响 → 继续                                     │
│    └─ ❌ 有影响 → 🔄 重新设计 → 回到步骤1                 │
│    ↓                                                        │
│ 5️⃣ 提交给用户                                              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 步骤详解

#### 0️⃣ 环境依赖预检查（前置步骤）

**在开始验证前确保所有必要的运行环境已就绪**

```bash
# 检测清单
- Homebrew (macOS包管理器)
- Git (版本控制)
- Xcode (iOS/macOS开发)
- Node.js/npm (如需要)
- Python (如需要)
- 数据库 (如需要)
```

**如果缺失依赖**：
- 🤖 **自动修复**：尝试自动安装（需要network权限）
- 📋 **提供指令**：给出详细安装步骤
- ✅ **验证安装**：安装后确认可用
- 🔄 **重新验证**：继续原验证流程

#### 2️⃣ 编译验证（必须）

```bash
# 对于 iOS/macOS 项目
xcodebuild -scheme TIME -destination 'platform=macOS' build
xcodebuild -scheme TIME -destination 'platform=iOS Simulator,name=iPhone 17' build

# 对于 Web 项目
npm run build  # 或其他构建命令

# 验证点
✅ 无编译错误
✅ 无新增警告
✅ 所有文件正确加载
```

**如果编译失败**：
- 🔍 分析错误信息
- 🔄 重新设计解决方案
- ✅ 再次编译验证

#### 3️⃣ 仿真测试（必须）

```bash
# 自动运行仿真
sleep 10 && cd /Users/shanwanjun/Desktop/cxs/time/time && echo "3" | ./run-simulation.sh

# 验证点
✅ Mac 应用启动成功
✅ iPhone 应用安装成功
✅ 修改的功能正常工作
✅ 无控制台错误
```

#### 4️⃣ 全局影响分析（必须）

**检查清单**：

```markdown
CSS 检查：
- [ ] 是否有同名 class/id 冲突？
- [ ] 是否有 CSS 优先级覆盖问题？
- [ ] 是否影响其他页面样式？
- [ ] 动画名称是否冲突？

JavaScript 检查：
- [ ] 全局变量是否冲突？
- [ ] 函数名是否重复？
- [ ] 事件监听器是否重复绑定？
- [ ] 是否影响其他模块？

数据检查：
- [ ] localStorage 键名是否冲突？
- [ ] 数据结构是否兼容？
- [ ] 是否需要数据迁移？

功能检查：
- [ ] 是否破坏现有功能？
- [ ] 是否需要更新文档？
- [ ] 是否需要更新测试？
```

**如果发现影响**：
- 🔄 重新设计，避免冲突
- 📝 更新相关文档
- ✅ 再次进行全流程验证

---

## 📚 解决方案知识库系统

### 知识库架构

```
~/.cursor-knowledge-base/          # 全局知识库
├── solutions/                     # 解决方案
│   ├── by-category/              # 按类别
│   │   ├── event-binding/        # 事件绑定问题
│   │   ├── initialization/       # 初始化问题
│   │   ├── data-storage/         # 数据存储问题
│   │   ├── ui-rendering/         # UI渲染问题
│   │   ├── performance/          # 性能优化
│   │   ├── cross-platform/       # 跨平台兼容
│   │   ├── security/             # 安全问题
│   │   ├── networking/           # 网络请求
│   │   ├── state-management/     # 状态管理
│   │   └── error-handling/       # 错误处理
│   ├── by-priority/              # 按优先级
│   │   ├── critical/             # 严重问题
│   │   ├── high/                 # 高优先级
│   │   └── medium/               # 中优先级
│   └── by-date/                  # 按日期
│       └── 2025-10/
├── patterns/                      # 设计模式
├── statistics/                    # 统计数据
│   └── solution-stats.json       # 解决方案统计
└── exports/                       # 导出文件
    ├── markdown/                 # Markdown格式
    └── pdf/                      # PDF格式
```

### 解决方案数据结构

```json
{
  "id": "solution-001",
  "title": "自定义分类按钮无响应问题",
  "category": "event-binding",
  "priority": "high",
  "created_at": "2025-10-26T07:00:00Z",
  "problem": {
    "description": "记录界面中的「+ 自定义」按钮点击无反应",
    "symptoms": [
      "点击按钮无任何响应",
      "控制台无错误信息",
      "按钮样式正常"
    ],
    "affected_platforms": ["iOS", "macOS", "Web"]
  },
  "diagnosis": {
    "root_cause": "SmartActivityTracker 未在 app-main.js 中统一初始化",
    "analysis": [
      "activity-tracker.js 使用局部变量创建实例",
      "app-main.js 未初始化 window.smartActivityTracker",
      "导致事件监听器绑定时 DOM 未准备好"
    ]
  },
  "solution": {
    "approach": "暴露类到 window，在 DOMContentLoaded 中统一初始化",
    "changes": [
      {
        "file": "activity-tracker.js",
        "line": 610,
        "change": "移除局部实例，改为暴露类"
      },
      {
        "file": "app-main.js",
        "lines": "1815-1821",
        "change": "添加 SmartActivityTracker 初始化"
      }
    ],
    "code_snippets": {
      "before": "const smartActivityTracker = new SmartActivityTracker();",
      "after": "window.SmartActivityTracker = SmartActivityTracker;"
    }
  },
  "verification": {
    "tested": true,
    "test_date": "2025-10-26",
    "platforms_tested": ["macOS", "iOS"],
    "result": "success",
    "notes": "编译成功，仿真运行正常，待用户确认功能"
  },
  "metadata": {
    "success_count": 1,
    "last_used": "2025-10-26",
    "tags": ["event-binding", "initialization", "dom-ready"],
    "related_issues": ["暂停按钮无响应"],
    "prevention": [
      "所有管理器类必须在 app-main.js 统一初始化",
      "确保 DOM 加载完成后再绑定事件",
      "使用 window 对象暴露全局实例"
    ]
  }
}
```

### 自动记录规则

**触发条件**（满足任一即记录）：
1. 用户明确说"已解决"、"功能正常"、"没问题了"
2. 修改后30秒内无新问题反馈
3. 用户开始新的任务/话题

**记录内容**：
- 问题完整描述
- 诊断过程
- 解决方案（含代码）
- 验证结果
- 预防措施

**下次遇到类似问题时**：
1. 🔍 自动检索知识库
2. 📊 匹配相似度 > 70% 的方案
3. ✅ 优先使用已验证的方案
4. 🎯 如成功，增加成功计数

---

## 🌍 跨平台一致性验证

### 支持平台清单

```
✅ 已支持平台：
  • iOS (原生 SwiftUI)
  • macOS (原生 SwiftUI)
  • Web (HTML5/CSS3/JS)

🔄 规划中平台：
  • Android (React Native / Flutter)
  • HarmonyOS 鸿蒙 (ArkTS / JS)
  • Web Progressive App (PWA)
  • 微信小程序
  • 支付宝小程序

🎯 跨平台兼容性目标：
  • 功能一致性：100%
  • UI一致性：90%以上
  • 数据同步：实时
  • 性能差异：<10%
```

### 平台验证矩阵

| 功能 | iOS | macOS | Web | Android | HarmonyOS |
|-----|-----|-------|-----|---------|-----------|
| 活动记录 | ✅ | ✅ | ✅ | 🔄 | 🔄 |
| 项目管理 | ✅ | ✅ | ✅ | 🔄 | 🔄 |
| 数据统计 | ✅ | ✅ | ✅ | 🔄 | 🔄 |
| 自定义分类 | ✅ | ✅ | ✅ | 🔄 | 🔄 |
| 安全区域 | ✅ | ✅ | N/A | 🔄 | 🔄 |

### 平台特定适配

```javascript
// 平台检测
const platform = {
  isIOS: /iPad|iPhone|iPod/.test(navigator.userAgent),
  isMacOS: /Macintosh/.test(navigator.userAgent),
  isAndroid: /Android/.test(navigator.userAgent),
  isHarmonyOS: /HarmonyOS/.test(navigator.userAgent),
  isWeb: !window.webkit && !window.Android
};

// 平台特定处理
if (platform.isIOS || platform.isMacOS) {
  // 处理安全区域
  document.documentElement.style.setProperty(
    '--safe-area-top',
    'env(safe-area-inset-top)'
  );
}
```

---

## 💾 文档同步与备份机制

### 备份策略

**重大修改前自动备份**：

```bash
# 备份命名规则
backups/{项目名称-v版本号}-{时间戳}/

# 示例
backups/
├── Activity-Tracker-v2.2.0-20251025-160000/
├── Activity-Tracker-v2.3.0-20251026-070000/
└── Activity-Tracker-v2.4.0-20251026-120000/
```

**触发条件**：
- 修改超过 100 行代码
- 重构核心模块
- 数据结构变更
- 用户明确要求

**备份内容**：
- 完整源代码
- .cursorrules 文件
- 配置文件
- Git 提交记录

**执行命令**：
```bash
# 创建备份
VERSION="Activity-Tracker-v2.4.0"
TIMESTAMP=$(date +%Y%m%d-%H%M%S)
BACKUP_DIR="backups/${VERSION}-${TIMESTAMP}"
mkdir -p "$BACKUP_DIR"
rsync -av --exclude='node_modules' --exclude='.git' \
      ./ "$BACKUP_DIR/"
git log --oneline -n 20 > "$BACKUP_DIR/git-history.txt"
```

### Git 版本标记

**重要版本必须打 Tag**：

```bash
# 标记版本（命名规则：项目名称-v版本号）
git tag -a Activity-Tracker-v2.5.0 -m "Activity Tracker v2.5.0 - 功能描述"
git push origin Activity-Tracker-v2.5.0

# Tag 命名规则
{项目名称}-v{主版本}.{次版本}.{修订版本}

示例：
  • Activity-Tracker-v2.5.0
  • Activity-Tracker-v3.0.0

版本号规则：
  主版本：重大架构变更
  次版本：新功能添加
  修订版本：Bug修复

项目名称：
  • Activity-Tracker（活动追踪器）
  • 其他项目使用对应的英文名称
```

### Git 双向同步规则 - MUST FOLLOW

**核心原则：本地和云端的规则文件(.cursorrules)必须保持同步**

#### 📥 云端 → 本地（拉取同步）

**每次开始工作前，必须先拉取云端更新**：

```bash
#!/bin/bash
# 自动检查并同步云端规则

sync_rules_from_remote() {
    echo "🔍 检查云端规则更新..."

    # 1. 获取远程更新（不合并）
    git fetch origin

    # 2. 检查.cursorrules是否有远程更新
    local remote_hash=$(git rev-parse origin/main:.cursorrules 2>/dev/null)
    local local_hash=$(git rev-parse HEAD:.cursorrules 2>/dev/null)

    if [ "$remote_hash" != "$local_hash" ]; then
        echo "📥 发现云端规则更新"

        # 3. 检查本地是否有未提交的修改
        if git diff --quiet .cursorrules; then
            # 本地无修改，直接拉取
            echo "✅ 本地无修改，自动拉取云端规则"
            git pull origin main
        else
            # 本地有修改，提示用户
            echo "⚠️  本地规则有未提交的修改"
            echo "选择操作："
            echo "  1) 暂存本地修改，拉取云端（推荐）"
            echo "  2) 放弃本地修改，使用云端版本"
            echo "  3) 保留本地修改，跳过同步"
            read -p "请选择 [1-3]: " choice

            case $choice in
                1)
                    git stash push -m "Auto-stash before sync" .cursorrules
                    git pull origin main
                    git stash pop
                    echo "✅ 已合并云端更新和本地修改"
                    ;;
                2)
                    git checkout origin/main -- .cursorrules
                    echo "✅ 已使用云端规则（本地修改已丢弃）"
                    ;;
                3)
                    echo "⊘ 跳过同步，保留本地修改"
                    ;;
            esac
        fi
    else
        echo "✅ 规则已是最新版本"
    fi
}

# 开始工作前自动执行
sync_rules_from_remote
```

#### 📤 本地 → 云端（推送同步）

**每次修改规则后，必须推送到云端**：

```bash
#!/bin/bash
# 自动提交并推送规则更新

push_rules_to_remote() {
    echo "📤 准备推送规则到云端..."

    # 1. 检查.cursorrules是否有修改
    if ! git diff --quiet .cursorrules; then
        echo "📝 检测到规则文件修改"

        # 2. 显示修改内容
        echo "修改摘要："
        git diff --stat .cursorrules

        # 3. 提交规则
        local current_version=$(grep "规则版本：" .cursorrules | head -1 | grep -o "v[0-9]\+\.[0-9]\+\.[0-9]\+")
        echo ""
        echo "当前规则版本：$current_version"
        read -p "输入提交说明（回车使用默认）: " commit_msg

        if [ -z "$commit_msg" ]; then
            commit_msg="feat: 更新规则文件 $current_version"
        fi

        git add .cursorrules
        git commit -m "$commit_msg"

        # 4. 推送到云端
        echo "📤 推送到云端..."
        if git push origin main; then
            echo "✅ 规则已同步到云端"

            # 5. 询问是否打Tag
            read -p "是否为此规则版本打Tag? (y/N): " tag_choice
            if [ "$tag_choice" = "y" ] || [ "$tag_choice" = "Y" ]; then
                git tag -a "Activity-Tracker-Rules-$current_version" -m "规则系统 $current_version"
                git push origin "Activity-Tracker-Rules-$current_version"
                echo "✅ Tag已推送"
            fi
        else
            echo "❌ 推送失败，请检查网络或权限"
            return 1
        fi
    else
        echo "⊘ 规则文件无修改，无需推送"
    fi
}

# 修改规则后自动执行
push_rules_to_remote
```

#### 🔄 自动同步策略

**AI必须在以下时机自动执行同步**：

1. **工作开始时**（每次会话开始）
   ```bash
   # 自动执行
   sync_rules_from_remote
   ```

2. **修改规则后**
   ```bash
   # 自动执行
   push_rules_to_remote
   ```

3. **定期同步**（每隔30分钟）
   ```bash
   # 后台执行
   while true; do
       sleep 1800  # 30分钟
       sync_rules_from_remote
   done &
   ```

#### 🔔 冲突解决策略

**当本地和云端都有修改时**：

```bash
resolve_rules_conflict() {
    echo "⚠️  检测到规则冲突"
    echo ""

    # 1. 显示冲突信息
    echo "本地修改："
    git diff HEAD .cursorrules | head -20
    echo ""
    echo "云端修改："
    git diff HEAD origin/main -- .cursorrules | head -20
    echo ""

    # 2. 提供解决方案
    echo "解决方案："
    echo "  1) 合并两者（推荐）- 保留双方的修改"
    echo "  2) 使用本地版本 - 覆盖云端"
    echo "  3) 使用云端版本 - 放弃本地"
    echo "  4) 手动解决 - 打开编辑器"
    read -p "请选择 [1-4]: " choice

    case $choice in
        1)
            # 尝试自动合并
            git merge origin/main
            if [ $? -eq 0 ]; then
                echo "✅ 自动合并成功"
                git push origin main
            else
                echo "❌ 自动合并失败，需要手动解决"
                echo "请编辑 .cursorrules 解决冲突，然后运行："
                echo "  git add .cursorrules"
                echo "  git commit -m 'merge: 解决规则冲突'"
                echo "  git push origin main"
            fi
            ;;
        2)
            # 使用本地版本
            git push origin main --force
            echo "⚠️  已强制推送本地版本（云端修改已丢失）"
            ;;
        3)
            # 使用云端版本
            git reset --hard origin/main
            echo "⚠️  已使用云端版本（本地修改已丢失）"
            ;;
        4)
            # 手动解决
            ${EDITOR:-vim} .cursorrules
            echo "请解决冲突后手动提交和推送"
            ;;
    esac
}
```

#### 📊 同步状态监控

**显示同步状态**：

```bash
check_rules_sync_status() {
    echo "📊 规则同步状态"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

    # 1. 本地版本
    local local_version=$(grep "规则版本：" .cursorrules | head -1 | grep -o "v[0-9]\+\.[0-9]\+\.[0-9]\+")
    echo "本地规则版本：$local_version"

    # 2. 最后提交时间
    local last_commit=$(git log -1 --format="%ci" -- .cursorrules)
    echo "最后修改时间：$last_commit"

    # 3. 是否有未推送的提交
    local unpushed=$(git log origin/main..HEAD --oneline -- .cursorrules | wc -l)
    if [ $unpushed -gt 0 ]; then
        echo "⚠️  有 $unpushed 个未推送的规则提交"
    else
        echo "✅ 所有规则修改已推送"
    fi

    # 4. 是否有未拉取的提交
    git fetch origin
    local unpulled=$(git log HEAD..origin/main --oneline -- .cursorrules | wc -l)
    if [ $unpulled -gt 0 ]; then
        echo "⚠️  云端有 $unpulled 个新的规则提交"
    else
        echo "✅ 已同步所有云端更新"
    fi

    # 5. 是否有未提交的修改
    if ! git diff --quiet .cursorrules; then
        echo "⚠️  有未提交的规则修改"
    else
        echo "✅ 无未提交的修改"
    fi

    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
}
```

#### 🎯 使用建议

**AI的自动行为**：

```
┌─────────────────────────────────────────────────────────┐
│ AI自动同步流程                                           │
├─────────────────────────────────────────────────────────┤
│                                                         │
│ 会话开始                                                │
│   ↓                                                    │
│ 检查云端更新 → 自动拉取                                │
│   ↓                                                    │
│ 用户提出需求                                            │
│   ↓                                                    │
│ AI修改规则                                             │
│   ↓                                                    │
│ 自动提交并推送 → 同步到云端                            │
│   ↓                                                    │
│ 继续工作...                                            │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

**用户手动命令**：

```bash
# 查看同步状态
check_rules_sync_status

# 手动拉取云端更新
sync_rules_from_remote

# 手动推送本地更新
push_rules_to_remote

# 解决冲突
resolve_rules_conflict
```

---

## 🔄 实时错误回退系统 - AUTO ROLLBACK

### 核心原则：出现错误立即自动回退到最近稳定状态

#### 自动快照机制

**AI必须在以下时机创建快照**：

1. **修改代码前**（每次重大修改）
   ```bash
   ./scripts/auto-snapshot.sh create
   ```

2. **重大功能完成后**
   ```bash
   ./scripts/auto-snapshot.sh create
   ```

3. **测试通过后**
   ```bash
   ./scripts/auto-snapshot.sh create
   ```

4. **用户明确要求时**
   ```bash
   ./scripts/auto-snapshot.sh create
   ```

#### 错误监控机制

**持续监控以下错误类型**：

```bash
# 执行一次性检查
./scripts/error-monitor.sh check

# 启动持续监控（后台运行）
./scripts/error-monitor.sh monitor &

# 停止监控
./scripts/error-monitor.sh stop
```

**监控项目**：
- ✅ 编译错误（xcodebuild）
- ✅ 运行时错误（应用崩溃、异常）
- ✅ JavaScript错误（控制台日志）
- ✅ 资源加载失败

#### 自动回退触发条件

**检测到以下情况立即回退**：

1. **编译失败**
   - xcodebuild返回错误
   - 语法错误
   - 依赖缺失
   - 类型不匹配

2. **运行时错误**
   - 应用崩溃
   - 未捕获异常
   - Fatal错误
   - 资源加载失败

3. **测试失败**（如果启用）
   - 单元测试不通过
   - 集成测试失败
   - 功能验证失败

#### 回退流程

```
┌─────────────────────────────────────────┐
│ 自动回退流程                             │
├─────────────────────────────────────────┤
│                                         │
│ 检测到错误                               │
│   ↓                                     │
│ 记录错误到日志                           │
│   ↓                                     │
│ 保存当前修改（git stash）                │
│   ↓                                     │
│ 获取最近稳定快照                         │
│   ↓                                     │
│ 回退到快照（git reset --hard）           │
│   ↓                                     │
│ 生成错误报告                             │
│   ↓                                     │
│ 通知用户                                 │
│   ↓                                     │
│ 停止监控，等待用户修复                   │
│                                         │
└─────────────────────────────────────────┘
```

#### 快照管理命令

```bash
# 创建快照
./scripts/auto-snapshot.sh create

# 查看快照列表
./scripts/auto-snapshot.sh list

# 清理所有快照
./scripts/auto-snapshot.sh clean

# 回退到特定快照
./scripts/rollback-to-snapshot.sh <快照名称>

# 自动回退（无确认）
./scripts/rollback-to-snapshot.sh <快照名称> --auto

# 查看可用快照
./scripts/rollback-to-snapshot.sh list
```

#### 恢复修改命令

**回退后如需恢复修改**：

```bash
# 查看保存的修改
git stash list

# 查看最近修改的详情
git stash show stash@{0}

# 恢复修改（保留stash）
git stash apply stash@{0}

# 恢复并删除stash
git stash pop

# 放弃stash
git stash drop stash@{0}
```

#### 错误报告

**系统自动生成错误报告**：

- **位置**: `.error-report-<timestamp>.md`
- **包含内容**:
  - 错误类型和时间
  - 回退的快照信息
  - 最近20条错误日志
  - 回退前的文件状态
  - 修复建议
  - 恢复命令

**查看错误报告**：
```bash
# 查看最新错误报告
ls -lt .error-report-*.md | head -1 | xargs cat

# 查看错误日志
tail -50 .error-monitor.log
```

#### 安全保护机制

1. **修改永不丢失**
   - 所有修改都保存到git stash
   - 可随时恢复
   - Stash有详细说明

2. **快照自动清理**
   - 自动保留最近20个快照
   - 避免占用过多空间
   - 可手动清理全部快照

3. **详细错误报告**
   - 自动生成Markdown格式报告
   - 包含错误原因分析
   - 提供修复建议
   - 记录恢复命令

4. **可选确认机制**
   - 自动模式（--auto）：直接回退
   - 手动模式（默认）：需要确认
   - 显示回退预览

#### 使用场景

**场景1：正常开发**
```bash
# 1. 开始新功能前
./scripts/auto-snapshot.sh create

# 2. 正常开发...

# 3. 功能完成后
./scripts/auto-snapshot.sh create

# 4. 继续下一个功能
```

**场景2：启用监控**
```bash
# 1. 启动后台监控
./scripts/error-monitor.sh monitor &

# 2. 正常开发...

# 3. 如果出错，系统自动回退

# 4. 查看错误报告，修复问题

# 5. 停止监控
./scripts/error-monitor.sh stop
```

**场景3：手动回退**
```bash
# 1. 发现问题，查看快照
./scripts/auto-snapshot.sh list

# 2. 回退到稳定快照
./scripts/rollback-to-snapshot.sh snapshot-20251026-143000

# 3. 确认代码正常

# 4. 需要时恢复修改
git stash apply

# 5. 修复后创建新快照
./scripts/auto-snapshot.sh create
```

#### AI自动行为

**AI必须自动执行**：

1. **修改前创建快照**
   - 每次重大修改前
   - 自动执行`./scripts/auto-snapshot.sh create`

2. **修改后检查错误**
   - 执行`./scripts/error-monitor.sh check`
   - 如果失败，自动回退

3. **持续开发时**（可选）
   - 后台启动监控
   - 自动检测错误
   - 自动触发回退

#### 配置选项

**错误监控配置**（在`scripts/error-monitor.sh`中）：

```bash
MONITOR_INTERVAL=30      # 监控间隔（秒）
MONITOR_COMPILE=true     # 监控编译错误
MONITOR_RUNTIME=true     # 监控运行时错误
AUTO_ROLLBACK=true       # 是否自动回退
```

**快照配置**（在`scripts/auto-snapshot.sh`中）：

```bash
MAX_SNAPSHOTS=20         # 最多保留快照数
SNAPSHOT_PREFIX="snapshot"  # 快照标签前缀
```

---

## 🚨 强制执行检查点系统 - CRITICAL

### ⚠️ 核心原则：硬约束，非软建议

**每个操作前必须通过所有检查点，否则立即终止**

### 🔴 检查点 0：接收用户请求后（强制）

```bash
# AI必须执行的命令
grep -i "关键词" .cursorrules
```

**强制检查清单**：
- [ ] 我是否搜索了相关规则？（执行grep命令）
- [ ] 我是否找到了相关规则？
- [ ] 我是否理解了规则内容？
- [ ] 我是否按规则设计方案？

**如果任何一项为"否"**：
```
❌ 立即停止
📋 报告："未搜索规则，违反元规则"
🔄 重新从检查点0开始
```

### 🟠 检查点 1：设计方案时（强制）

**全局影响分析检查清单**：
- [ ] 文件路径是否与现有结构一致？
- [ ] 是否检查了所有JS引用路径？
- [ ] 是否检查了CSS引用路径？
- [ ] 命名是否符合项目规范？
- [ ] 版本号格式是否正确？
- [ ] 是否会影响其他模块？
- [ ] 是否有全局变量冲突？
- [ ] 是否有函数名重复？

**如果任何一项为"否"**：
```
❌ 立即停止
🔄 重新设计方案
📋 执行完整的全局影响分析
```

### 🟡 检查点 2：修改代码前（强制）

**沙盒验证检查清单**：
- [ ] 我是否创建了沙盒环境？
- [ ] 我是否在沙盒中应用了修改？
- [ ] 我是否在沙盒中编译成功？
- [ ] 我是否在沙盒中测试通过？
- [ ] 我是否准备了回滚方案？

**如果任何一项为"否"**：
```
❌ 禁止修改用户代码
📋 报告："未经沙盒验证，违反安全规范"
🔄 返回检查点2，完成沙盒验证
```

### 🟢 检查点 3：提交给用户前（强制）

**最终验证检查清单**：
- [ ] 编译是否成功？
- [ ] 仿真测试是否通过？
- [ ] Mac应用是否正常显示？
- [ ] iPhone应用是否正常显示？
- [ ] 是否生成了验证报告？
- [ ] 是否等待用户最终确认？

**如果任何一项为"否"**：
```
❌ 不能提交给用户
🔄 回到相应检查点修复问题
♻️  循环直到全部通过
```

---

## 💻 专业代码设计规范 - MUST FOLLOW

### 设计原则：从资深开发者角度设计代码

#### 1️⃣ 全局项目视角（必须考虑）

**设计任何代码前的思考流程**：

```
┌─────────────────────────────────────────────────────────┐
│ 专业开发者思维模式                                       │
├─────────────────────────────────────────────────────────┤
│                                                         │
│ 需求理解                                                │
│   ↓                                                    │
│ 分析整体架构（这段代码在项目中的位置）                  │
│   ↓                                                    │
│ 检查现有代码（是否有类似功能？是否需要重构？）          │
│   ↓                                                    │
│ 设计模块接口（如何与其他模块交互？）                    │
│   ↓                                                    │
│ 选择设计模式（单例？观察者？工厂？）                    │
│   ↓                                                    │
│ 考虑性能影响（是否需要缓存？防抖？节流？）              │
│   ↓                                                    │
│ 编写代码（符合语言规范和项目风格）                      │
│   ↓                                                    │
│ 添加错误处理（try-catch、边界检查）                    │
│   ↓                                                    │
│ 编写注释文档（JSDoc格式）                               │
│   ↓                                                    │
│ 考虑测试方案（如何验证？）                              │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

#### 2️⃣ JavaScript规范（ES6+）

```javascript
// ✅ 正确示例：完整的类设计

/**
 * 活动追踪器类
 * @class ActivityTracker
 * @description 管理活动的记录、存储和展示
 */
class ActivityTracker {
    /**
     * @constructor
     */
    constructor() {
        this.activities = [];
        this.currentActivity = null;
        this.storageKey = 'activityTracker_activities';
        this.init();
    }

    /**
     * 初始化
     * @private
     */
    init() {
        this.loadData();
        this.setupEventListeners();
    }

    /**
     * 加载数据
     * @private
     * @returns {Array} 活动列表
     */
    loadData() {
        try {
            const data = localStorage.getItem(this.storageKey);
            this.activities = data ? JSON.parse(data) : [];
            return this.activities;
        } catch (error) {
            console.error('加载数据失败:', error);
            return [];
        }
    }

    /**
     * 保存数据
     * @private
     */
    saveData() {
        try {
            localStorage.setItem(
                this.storageKey,
                JSON.stringify(this.activities)
            );
        } catch (error) {
            console.error('保存数据失败:', error);
            this.handleStorageError(error);
        }
    }

    /**
     * 处理存储错误
     * @private
     * @param {Error} error - 错误对象
     */
    handleStorageError(error) {
        if (error.name === 'QuotaExceededError') {
            alert('存储空间已满，请清理数据');
        }
    }

    /**
     * 设置事件监听器
     * @private
     */
    setupEventListeners() {
        document.addEventListener('DOMContentLoaded', () => {
            this.render();
        });
    }

    /**
     * 渲染界面
     * @public
     */
    render() {
        // 渲染逻辑
    }
}

// 导出到window（全局单例）
if (typeof window !== 'undefined') {
    window.ActivityTracker = ActivityTracker;
}
```

#### 3️⃣ CSS规范（BEM + 变量）

```css
/* ✅ 正确示例：可维护的CSS */

/* CSS变量定义 */
:root {
    /* 颜色系统 */
    --primary-color: #667eea;
    --secondary-color: #764ba2;
    --success-color: #10b981;
    --error-color: #ef4444;

    /* 间距系统（8px基准）*/
    --space-xs: 4px;
    --space-sm: 8px;
    --space-md: 16px;
    --space-lg: 24px;
    --space-xl: 32px;

    /* 字体系统 */
    --font-size-sm: 14px;
    --font-size-base: 16px;
    --font-size-lg: 18px;
    --font-size-xl: 24px;

    /* 边框半径 */
    --radius-sm: 8px;
    --radius-md: 12px;
    --radius-lg: 16px;

    /* 阴影系统 */
    --shadow-sm: 0 2px 4px rgba(0,0,0,0.1);
    --shadow-md: 0 4px 8px rgba(0,0,0,0.15);
    --shadow-lg: 0 8px 16px rgba(0,0,0,0.2);
}

/* BEM命名规范 */
.activity-card {
    /* 布局 */
    display: flex;
    flex-direction: column;
    gap: var(--space-md);

    /* 尺寸 */
    padding: var(--space-lg);
    margin-bottom: var(--space-md);

    /* 外观 */
    background: white;
    border-radius: var(--radius-md);
    box-shadow: var(--shadow-md);

    /* 交互 */
    transition: all 0.3s ease;
    cursor: pointer;
}

.activity-card:hover {
    transform: translateY(-4px);
    box-shadow: var(--shadow-lg);
}

.activity-card__title {
    font-size: var(--font-size-lg);
    font-weight: 600;
    color: var(--primary-color);
}

.activity-card__title--highlighted {
    color: var(--secondary-color);
}

.activity-card__content {
    font-size: var(--font-size-base);
    line-height: 1.6;
}

/* 响应式设计（移动优先）*/
@media (min-width: 768px) {
    .activity-card {
        padding: var(--space-xl);
    }
}
```

#### 4️⃣ HTML规范（语义化 + 可访问性）

```html
<!-- ✅ 正确示例：语义化HTML -->

<main class="app-container" role="main">
    <!-- 导航区域 -->
    <nav class="app-nav" role="navigation" aria-label="主导航">
        <ul class="nav-list">
            <li class="nav-item">
                <a href="#record"
                   class="nav-link"
                   aria-current="page">
                    记录
                </a>
            </li>
        </ul>
    </nav>

    <!-- 内容区域 -->
    <section class="content-section" aria-labelledby="section-title">
        <header class="section-header">
            <h2 id="section-title" class="section-title">活动记录</h2>
        </header>

        <article class="activity-item"
                 data-id="123"
                 data-status="active"
                 role="article">
            <header class="activity-header">
                <h3 class="activity-title">活动标题</h3>
                <time datetime="2025-10-26T22:00:00"
                      class="activity-time">
                    22:00
                </time>
            </header>

            <div class="activity-body">
                <p class="activity-description">活动描述</p>
            </div>

            <footer class="activity-footer">
                <button type="button"
                        class="btn btn--primary"
                        aria-label="开始此活动">
                    开始
                </button>
            </footer>
        </article>
    </section>
</main>
```

---

## 🤖 自动化沙盒验证流程 - MUST FOLLOW

### 核心原则：修改用户代码前，必须在沙盒中完整验证

**AI必须做到：全自动，无需用户介入**

### 工作流程

```bash
#!/bin/bash
# 自动化沙盒验证主流程

SANDBOX_DIR="/tmp/activity-tracker-sandbox-$(date +%s)"
USER_DIR="/Users/shanwanjun/Desktop/cxs/time"
MAX_ATTEMPTS=5
TIMEOUT=300

# 1️⃣ 创建沙盒环境
create_sandbox() {
    echo "🔧 创建沙盒环境..."

    # 检查磁盘空间
    available=$(df -BG /tmp | tail -1 | awk '{print $4}' | sed 's/G//')
    if [ $available -lt 5 ]; then
        echo "❌ 磁盘空间不足"
        return 1
    fi

    # 复制项目（排除敏感数据）
    mkdir -p "$SANDBOX_DIR"
    rsync -a \
        --exclude='.env*' \
        --exclude='*.pem' \
        --exclude='*.key' \
        --exclude='node_modules' \
        --exclude='.git' \
        --exclude='DerivedData' \
        "$USER_DIR/" \
        "$SANDBOX_DIR/"

    # 创建沙盒标记
    touch "$SANDBOX_DIR/.SANDBOX_ACTIVE"

    echo "✅ 沙盒创建完成: $SANDBOX_DIR"
    return 0
}

# 2️⃣ 自动编译（循环直到成功）
auto_compile() {
    local attempt=1
    local start_time=$(date +%s)

    while [ $attempt -le $MAX_ATTEMPTS ]; do
        # 检查超时
        local current_time=$(date +%s)
        local elapsed=$((current_time - start_time))
        if [ $elapsed -ge $TIMEOUT ]; then
            echo "❌ 编译超时"
            return 1
        fi

        echo "🔨 编译尝试 $attempt/$MAX_ATTEMPTS..."

        cd "$SANDBOX_DIR/time"
        if xcodebuild clean build \
           -scheme time \
           -destination 'platform=macOS' \
           2>&1 | tee compile.log; then
            echo "✅ 编译成功"
            return 0
        else
            echo "❌ 编译失败，分析错误..."

            # 自动修复常见问题
            if grep -q "No such file or directory.*\.js" compile.log; then
                echo "🔧 修复：JavaScript文件路径问题"
                fix_js_paths
            fi

            attempt=$((attempt + 1))
        fi
    done

    echo "❌ 编译失败，已达最大尝试次数"
    return 1
}

# 3️⃣ 自动测试（循环直到成功）
auto_test() {
    local attempt=1

    while [ $attempt -le $MAX_ATTEMPTS ]; do
        echo "🧪 测试尝试 $attempt/$MAX_ATTEMPTS..."

        # 启动应用
        open "$APP_PATH"
        sleep 10

        # 自动检查
        local all_passed=true

        # 检查进程
        if ! ps aux | grep "TIME.app" | grep -v grep > /dev/null; then
            echo "❌ 应用进程不存在"
            all_passed=false
        fi

        # 检查窗口
        if ! osascript -e 'tell application "System Events" to exists window 1 of process "TIME"' 2>/dev/null; then
            echo "❌ 应用窗口不存在"
            all_passed=false
        fi

        # 检查JavaScript错误
        if log show --predicate 'processImagePath contains "TIME"' --last 10s 2>/dev/null | grep -i "404\|not found" > /dev/null; then
            echo "❌ JavaScript加载失败"
            all_passed=false

            # 自动修复
            fix_js_loading_issues
        fi

        if [ "$all_passed" = true ]; then
            echo "✅ 所有测试通过"
            return 0
        fi

        attempt=$((attempt + 1))
    done

    return 1
}

# 4️⃣ 应用到用户代码
apply_to_user() {
    echo "📋 应用到用户代码..."

    # 只复制修改的文件
    rsync -a --update \
          --exclude='.SANDBOX_ACTIVE' \
          "$SANDBOX_DIR/time/time/Web/" \
          "$USER_DIR/time/time/Web/"

    echo "✅ 已应用到用户项目"
}

# 5️⃣ 清理沙盒
cleanup() {
    echo "🧹 清理沙盒..."
    rm -rf "$SANDBOX_DIR"
}

# 主流程
main() {
    echo "🚀 开始自动化沙盒验证..."

    if ! create_sandbox; then
        echo "❌ 创建沙盒失败"
        exit 1
    fi

    if ! auto_compile; then
        echo "❌ 编译验证失败"
        cleanup
        exit 1
    fi

    if ! auto_test; then
        echo "❌ 功能测试失败"
        cleanup
        exit 1
    fi

    apply_to_user
    cleanup

    echo "✅ 全部完成！"
}

main
```

---

**最后更新：** 2025年10月26日23:00
**规则版本：** Activity-Tracker-Rules-v5.0.0
**状态：** ✅ 生效中（新增强制检查点系统）
